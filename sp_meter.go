// This file is generated by the generate_components.py script
// Do not edit this file manually

package sp

import "github.com/maxence-charriere/go-app/v10/pkg/app"

// MeterSize represents the Size variant for the meter
type MeterSize string

// MeterSize values
const (
	MeterSizeS MeterSize = "s"
	MeterSizeM MeterSize = "m"
	MeterSizeL MeterSize = "l"
)

// MeterVariant represents the The visual style to apply to this meter
type MeterVariant string

// MeterVariant values
const (
	MeterVariantPositive MeterVariant = "positive"
	MeterVariantNegative MeterVariant = "negative"
	MeterVariantNotice   MeterVariant = "notice"
	MeterVariantNeutral  MeterVariant = "neutral"
)

// spectrumMeter represents an sp-meter component
type spectrumMeter struct {
	app.Compo
	*styler[*spectrumMeter]
	*classer[*spectrumMeter]
	*ider[*spectrumMeter]

	// Properties
	// The accessible label for this meter
	PropLabel string
	// The maximum value for this meter
	PropMax float64
	// The minimum value for this meter
	PropMin float64
	// Whether to display the meter with a neutral color instead of the default positive color
	PropNeutral bool
	// Whether to display the meter with the notice color
	PropNotice bool
	// Whether the meter is to be displayed over a background
	PropOverbackground bool
	// A percentage value (0-100) for the meter; calculated from value, min, and max if not provided
	PropPercentage float64
	// Whether to display the meter with the positive color
	PropPositive bool
	// Optional side label to display next to the meter value
	PropSideLabel string
	// Size variant for the meter
	PropSize MeterSize
	// The current value for this meter
	PropValue float64
	// The visual style to apply to this meter
	PropVariant MeterVariant

	// Content slots
	PropLabelSlot app.UI
	PropValueSlot app.UI
}

// IMeter is the interface for sp-meter component methods
type IMeter interface {
	app.UI
	Styler[IMeter]
	Classer[IMeter]
	Ider[IMeter]
	Label(string) IMeter
	Max(float64) IMeter
	Min(float64) IMeter
	Neutral(bool) IMeter
	SetNeutral() IMeter
	Notice(bool) IMeter
	SetNotice() IMeter
	Overbackground(bool) IMeter
	SetOverbackground() IMeter
	Percentage(float64) IMeter
	Positive(bool) IMeter
	SetPositive() IMeter
	SideLabel(string) IMeter
	Size(MeterSize) IMeter
	SizeS() IMeter
	SizeM() IMeter
	SizeL() IMeter
	Value(float64) IMeter
	Variant(MeterVariant) IMeter
	VariantPositive() IMeter
	VariantNegative() IMeter
	VariantNotice() IMeter
	VariantNeutral() IMeter

	LabelContent(app.UI) IMeter
	ValueContent(app.UI) IMeter
}

// Meter Used to display a value in a range utilizing a colored bar displaying progress towards a target.
func Meter() IMeter {
	element := &spectrumMeter{
		PropLabel:          "",
		PropMax:            100,
		PropMin:            0,
		PropNeutral:        false,
		PropNotice:         false,
		PropOverbackground: false,
		PropPercentage:     0,
		PropPositive:       true,
		PropSideLabel:      "",
		PropSize:           MeterSizeM,
		PropValue:          0,
		PropVariant:        MeterVariantPositive,
	}

	element.styler = newStyler(element)
	element.classer = newClasser(element)
	element.ider = newIder(element)

	return element
}

// Label The accessible label for this meter
func (c *spectrumMeter) Label(label string) IMeter {
	c.PropLabel = label
	return c
}

// Max The maximum value for this meter
func (c *spectrumMeter) Max(max float64) IMeter {
	c.PropMax = max
	return c
}

// Min The minimum value for this meter
func (c *spectrumMeter) Min(min float64) IMeter {
	c.PropMin = min
	return c
}

// Neutral Whether to display the meter with a neutral color instead of the default positive color
func (c *spectrumMeter) Neutral(neutral bool) IMeter {
	c.PropNeutral = neutral
	return c
}

func (c *spectrumMeter) SetNeutral() IMeter {
	return c.Neutral(true)
}

// Notice Whether to display the meter with the notice color
func (c *spectrumMeter) Notice(notice bool) IMeter {
	c.PropNotice = notice
	return c
}

func (c *spectrumMeter) SetNotice() IMeter {
	return c.Notice(true)
}

// Overbackground Whether the meter is to be displayed over a background
func (c *spectrumMeter) Overbackground(overBackground bool) IMeter {
	c.PropOverbackground = overBackground
	return c
}

func (c *spectrumMeter) SetOverbackground() IMeter {
	return c.Overbackground(true)
}

// Percentage A percentage value (0-100) for the meter; calculated from value, min, and max if not provided
func (c *spectrumMeter) Percentage(percentage float64) IMeter {
	c.PropPercentage = percentage
	return c
}

// Positive Whether to display the meter with the positive color
func (c *spectrumMeter) Positive(positive bool) IMeter {
	c.PropPositive = positive
	return c
}

func (c *spectrumMeter) SetPositive() IMeter {
	return c.Positive(true)
}

// SideLabel Optional side label to display next to the meter value
func (c *spectrumMeter) SideLabel(sideLabel string) IMeter {
	c.PropSideLabel = sideLabel
	return c
}

// Size Size variant for the meter
func (c *spectrumMeter) Size(size MeterSize) IMeter {
	c.PropSize = size
	return c
}

func (c *spectrumMeter) SizeS() IMeter {
	return c.Size(MeterSizeS)
}
func (c *spectrumMeter) SizeM() IMeter {
	return c.Size(MeterSizeM)
}
func (c *spectrumMeter) SizeL() IMeter {
	return c.Size(MeterSizeL)
}

// Value The current value for this meter
func (c *spectrumMeter) Value(value float64) IMeter {
	c.PropValue = value
	return c
}

// Variant The visual style to apply to this meter
func (c *spectrumMeter) Variant(variant MeterVariant) IMeter {
	c.PropVariant = variant
	return c
}

func (c *spectrumMeter) VariantPositive() IMeter {
	return c.Variant(MeterVariantPositive)
}
func (c *spectrumMeter) VariantNegative() IMeter {
	return c.Variant(MeterVariantNegative)
}
func (c *spectrumMeter) VariantNotice() IMeter {
	return c.Variant(MeterVariantNotice)
}
func (c *spectrumMeter) VariantNeutral() IMeter {
	return c.Variant(MeterVariantNeutral)
}

// Content for the meter label
func (c *spectrumMeter) LabelContent(content app.UI) IMeter {
	c.PropLabelSlot = content

	return c
}

// Content to display as the meter value
func (c *spectrumMeter) ValueContent(content app.UI) IMeter {
	c.PropValueSlot = content

	return c
}

// Style sets a style property with a value
func (c *spectrumMeter) Style(key, format string, values ...any) IMeter {
	return c.styler.Style(key, format, values...)
}

// Styles sets multiple style properties
func (c *spectrumMeter) Styles(styles map[string]string) IMeter {
	return c.styler.Styles(styles)
}

// Class adds a class to the element
func (c *spectrumMeter) Class(class string) IMeter {
	return c.classer.Class(class)
}

// Classes adds multiple classes to the element
func (c *spectrumMeter) Classes(classes ...string) IMeter {
	return c.classer.Classes(classes...)
}

// Id sets the id of the element
func (c *spectrumMeter) Id(id string) IMeter {
	return c.ider.Id(id)
}

// Render renders the sp-meter component
func (c *spectrumMeter) Render() app.UI {
	element := app.Elem("sp-meter")

	// Set attributes
	if c.PropLabel != "" {
		element = element.Attr("label", c.PropLabel)
	}
	if c.PropMax != 0 {
		element = element.Attr("max", c.PropMax)
	}
	if c.PropMin != 0 {
		element = element.Attr("min", c.PropMin)
	}
	if c.PropNeutral {
		element = element.Attr("neutral", true)
	}
	if c.PropNotice {
		element = element.Attr("notice", true)
	}
	if c.PropOverbackground {
		element = element.Attr("overBackground", true)
	}
	if c.PropPercentage != 0 {
		element = element.Attr("percentage", c.PropPercentage)
	}
	if c.PropPositive {
		element = element.Attr("positive", true)
	}
	if c.PropSideLabel != "" {
		element = element.Attr("side-label", c.PropSideLabel)
	}
	if c.PropSize != "" {
		element = element.Attr("size", string(c.PropSize))
	}
	if c.PropValue != 0 {
		element = element.Attr("value", c.PropValue)
	}
	if c.PropVariant != "" {
		element = element.Attr("variant", string(c.PropVariant))
	}

	// Add slots and children
	slotElements := []app.UI{}

	// Add label slot
	if c.PropLabelSlot != nil {
		slotElem := c.PropLabelSlot
		if slotWithAttr, ok := slotElem.(interface{ Slot(string) app.UI }); ok {
			slotElem = slotWithAttr.Slot("label")
		} else {
			slotElem = app.Elem("div").
				Attr("slot", "label").
				Body(slotElem)
		}
		slotElements = append(slotElements, slotElem)
	}
	// Add value slot
	if c.PropValueSlot != nil {
		slotElem := c.PropValueSlot
		if slotWithAttr, ok := slotElem.(interface{ Slot(string) app.UI }); ok {
			slotElem = slotWithAttr.Slot("value")
		} else {
			slotElem = app.Elem("div").
				Attr("slot", "value").
				Body(slotElem)
		}
		slotElements = append(slotElements, slotElem)
	}

	// Add all elements to the component
	if len(slotElements) > 0 {
		element = element.Body(slotElements...)
	}

	// Apply styles, classes, and id
	element = element.Styles(c.styler.styles)

	// Apply classes if any
	if len(c.classer.classes) > 0 {
		element = element.Class(c.classer.classes...)
	}

	// Apply id if set
	if c.ider.id != "" {
		element = element.ID(c.ider.id)
	}

	return element
}
