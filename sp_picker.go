// This file is generated by the generate_components.py script
// Do not edit this file manually

package sp

import "github.com/maxence-charriere/go-app/v10/pkg/app"

// PickerIcons represents the How icons are displayed
type PickerIcons string

// PickerIcons values
const (
	PickerIconsOnly PickerIcons = "only"
	PickerIconsNone PickerIcons = "none"
)

// PickerPlacement represents the Positioning of the dropdown menu
type PickerPlacement string

// PickerPlacement values
const (
	PickerPlacementTop         PickerPlacement = "top"
	PickerPlacementTopStart    PickerPlacement = "top-start"
	PickerPlacementTopEnd      PickerPlacement = "top-end"
	PickerPlacementRight       PickerPlacement = "right"
	PickerPlacementRightStart  PickerPlacement = "right-start"
	PickerPlacementRightEnd    PickerPlacement = "right-end"
	PickerPlacementBottom      PickerPlacement = "bottom"
	PickerPlacementBottomStart PickerPlacement = "bottom-start"
	PickerPlacementBottomEnd   PickerPlacement = "bottom-end"
	PickerPlacementLeft        PickerPlacement = "left"
	PickerPlacementLeftStart   PickerPlacement = "left-start"
	PickerPlacementLeftEnd     PickerPlacement = "left-end"
)

// spectrumPicker represents an sp-picker component
type spectrumPicker struct {
	app.Compo
	*styler[*spectrumPicker]
	*classer[*spectrumPicker]
	*ider[*spectrumPicker]

	// Properties
	// Disable this control
	PropDisabled bool
	// Forces rendering as popover on mobile instead of tray
	PropForcepopover bool
	// How icons are displayed
	PropIcons PickerIcons
	// Whether the picker is invalid
	PropInvalid bool
	// Accessible label when visible label not provided
	PropLabel string
	// Whether the menu is open
	PropOpen bool
	// Whether items are currently loading
	PropPending bool
	// Label for the picker in pending state
	PropPendinglabel string
	// Positioning of the dropdown menu
	PropPlacement PickerPlacement
	// Display without visible background
	PropQuiet bool
	// Whether user can interact with the value
	PropReadonly bool
	// The value of the selected option
	PropValue string

	// Content for default slot
	PropBody []app.UI

	// Content slots
	PropDescriptionSlot app.UI
	PropLabelSlot       app.UI
	PropTooltipSlot     app.UI

	// Event handlers
	PropOnChange   app.EventHandler
	PropOnSpOpened app.EventHandler
}

// IPicker is the interface for sp-picker component methods
type IPicker interface {
	app.UI
	Styler[IPicker]
	Classer[IPicker]
	Ider[IPicker]
	Disabled(bool) IPicker
	SetDisabled() IPicker
	Forcepopover(bool) IPicker
	SetForcepopover() IPicker
	Icons(PickerIcons) IPicker
	IconsOnly() IPicker
	IconsNone() IPicker
	Invalid(bool) IPicker
	SetInvalid() IPicker
	Label(string) IPicker
	Open(bool) IPicker
	SetOpen() IPicker
	Pending(bool) IPicker
	SetPending() IPicker
	Pendinglabel(string) IPicker
	Placement(PickerPlacement) IPicker
	PlacementTop() IPicker
	PlacementTopStart() IPicker
	PlacementTopEnd() IPicker
	PlacementRight() IPicker
	PlacementRightStart() IPicker
	PlacementRightEnd() IPicker
	PlacementBottom() IPicker
	PlacementBottomStart() IPicker
	PlacementBottomEnd() IPicker
	PlacementLeft() IPicker
	PlacementLeftStart() IPicker
	PlacementLeftEnd() IPicker
	Quiet(bool) IPicker
	SetQuiet() IPicker
	Readonly(bool) IPicker
	SetReadonly() IPicker
	Value(string) IPicker

	Body(...app.UI) IPicker
	AddToBody(app.UI) IPicker
	Text(string) IPicker

	Description(app.UI) IPicker
	LabelContent(app.UI) IPicker
	Tooltip(app.UI) IPicker

	OnChange(app.EventHandler) IPicker
	OnSpOpened(app.EventHandler) IPicker
}

// Picker An alternative to HTML's select element using menu items for available options.
func Picker() IPicker {
	element := &spectrumPicker{
		PropDisabled:     false,
		PropForcepopover: false,
		PropIcons:        "",
		PropInvalid:      false,
		PropLabel:        "",
		PropOpen:         false,
		PropPending:      false,
		PropPendinglabel: "Pending",
		PropPlacement:    PickerPlacementBottomStart,
		PropQuiet:        false,
		PropReadonly:     false,
		PropValue:        "",
		PropBody:         []app.UI{},
	}

	element.styler = newStyler(element)
	element.classer = newClasser(element)
	element.ider = newIder(element)

	return element
}

// Disabled Disable this control
func (c *spectrumPicker) Disabled(disabled bool) IPicker {
	c.PropDisabled = disabled
	return c
}

func (c *spectrumPicker) SetDisabled() IPicker {
	return c.Disabled(true)
}

// Forcepopover Forces rendering as popover on mobile instead of tray
func (c *spectrumPicker) Forcepopover(forcePopover bool) IPicker {
	c.PropForcepopover = forcePopover
	return c
}

func (c *spectrumPicker) SetForcepopover() IPicker {
	return c.Forcepopover(true)
}

// Icons How icons are displayed
func (c *spectrumPicker) Icons(icons PickerIcons) IPicker {
	c.PropIcons = icons
	return c
}

func (c *spectrumPicker) IconsOnly() IPicker {
	return c.Icons(PickerIconsOnly)
}
func (c *spectrumPicker) IconsNone() IPicker {
	return c.Icons(PickerIconsNone)
}

// Invalid Whether the picker is invalid
func (c *spectrumPicker) Invalid(invalid bool) IPicker {
	c.PropInvalid = invalid
	return c
}

func (c *spectrumPicker) SetInvalid() IPicker {
	return c.Invalid(true)
}

// Label Accessible label when visible label not provided
func (c *spectrumPicker) Label(label string) IPicker {
	c.PropLabel = label
	return c
}

// Open Whether the menu is open
func (c *spectrumPicker) Open(open bool) IPicker {
	c.PropOpen = open
	return c
}

func (c *spectrumPicker) SetOpen() IPicker {
	return c.Open(true)
}

// Pending Whether items are currently loading
func (c *spectrumPicker) Pending(pending bool) IPicker {
	c.PropPending = pending
	return c
}

func (c *spectrumPicker) SetPending() IPicker {
	return c.Pending(true)
}

// Pendinglabel Label for the picker in pending state
func (c *spectrumPicker) Pendinglabel(pendingLabel string) IPicker {
	c.PropPendinglabel = pendingLabel
	return c
}

// Placement Positioning of the dropdown menu
func (c *spectrumPicker) Placement(placement PickerPlacement) IPicker {
	c.PropPlacement = placement
	return c
}

func (c *spectrumPicker) PlacementTop() IPicker {
	return c.Placement(PickerPlacementTop)
}
func (c *spectrumPicker) PlacementTopStart() IPicker {
	return c.Placement(PickerPlacementTopStart)
}
func (c *spectrumPicker) PlacementTopEnd() IPicker {
	return c.Placement(PickerPlacementTopEnd)
}
func (c *spectrumPicker) PlacementRight() IPicker {
	return c.Placement(PickerPlacementRight)
}
func (c *spectrumPicker) PlacementRightStart() IPicker {
	return c.Placement(PickerPlacementRightStart)
}
func (c *spectrumPicker) PlacementRightEnd() IPicker {
	return c.Placement(PickerPlacementRightEnd)
}
func (c *spectrumPicker) PlacementBottom() IPicker {
	return c.Placement(PickerPlacementBottom)
}
func (c *spectrumPicker) PlacementBottomStart() IPicker {
	return c.Placement(PickerPlacementBottomStart)
}
func (c *spectrumPicker) PlacementBottomEnd() IPicker {
	return c.Placement(PickerPlacementBottomEnd)
}
func (c *spectrumPicker) PlacementLeft() IPicker {
	return c.Placement(PickerPlacementLeft)
}
func (c *spectrumPicker) PlacementLeftStart() IPicker {
	return c.Placement(PickerPlacementLeftStart)
}
func (c *spectrumPicker) PlacementLeftEnd() IPicker {
	return c.Placement(PickerPlacementLeftEnd)
}

// Quiet Display without visible background
func (c *spectrumPicker) Quiet(quiet bool) IPicker {
	c.PropQuiet = quiet
	return c
}

func (c *spectrumPicker) SetQuiet() IPicker {
	return c.Quiet(true)
}

// Readonly Whether user can interact with the value
func (c *spectrumPicker) Readonly(readonly bool) IPicker {
	c.PropReadonly = readonly
	return c
}

func (c *spectrumPicker) SetReadonly() IPicker {
	return c.Readonly(true)
}

// Value The value of the selected option
func (c *spectrumPicker) Value(value string) IPicker {
	c.PropValue = value
	return c
}

// Body sets the content for the default slot
func (c *spectrumPicker) Body(elements ...app.UI) IPicker {
	c.PropBody = elements
	return c
}

// AddToBody adds a UI element to the default slot
func (c *spectrumPicker) AddToBody(element app.UI) IPicker {
	c.PropBody = append(c.PropBody, element)
	return c
}

// Text sets text content for the default slot
func (c *spectrumPicker) Text(text string) IPicker {
	c.PropBody = []app.UI{app.Text(text)}
	return c
}

// Description content for the picker
func (c *spectrumPicker) Description(content app.UI) IPicker {
	c.PropDescriptionSlot = content

	return c
}

// Label content for the picker
func (c *spectrumPicker) LabelContent(content app.UI) IPicker {
	c.PropLabelSlot = content

	return c
}

// Tooltip for the picker button
func (c *spectrumPicker) Tooltip(content app.UI) IPicker {
	c.PropTooltipSlot = content

	return c
}

// Value of the element has changed
func (c *spectrumPicker) OnChange(handler app.EventHandler) IPicker {
	c.PropOnChange = handler

	return c
}

// Announces that the overlay has been opened
func (c *spectrumPicker) OnSpOpened(handler app.EventHandler) IPicker {
	c.PropOnSpOpened = handler

	return c
}

// Style sets a style property with a value
func (c *spectrumPicker) Style(key, format string, values ...any) IPicker {
	return c.styler.Style(key, format, values...)
}

// Styles sets multiple style properties
func (c *spectrumPicker) Styles(styles map[string]string) IPicker {
	return c.styler.Styles(styles)
}

// Class adds a class to the element
func (c *spectrumPicker) Class(class string) IPicker {
	return c.classer.Class(class)
}

// Classes adds multiple classes to the element
func (c *spectrumPicker) Classes(classes ...string) IPicker {
	return c.classer.Classes(classes...)
}

// Id sets the id of the element
func (c *spectrumPicker) Id(id string) IPicker {
	return c.ider.Id(id)
}

// Render renders the sp-picker component
func (c *spectrumPicker) Render() app.UI {
	element := app.Elem("sp-picker")

	// Set attributes
	if c.PropDisabled {
		element = element.Attr("disabled", true)
	}
	if c.PropForcepopover {
		element = element.Attr("forcePopover", true)
	}
	if c.PropIcons != "" {
		element = element.Attr("icons", string(c.PropIcons))
	}
	if c.PropInvalid {
		element = element.Attr("invalid", true)
	}
	if c.PropLabel != "" {
		element = element.Attr("label", c.PropLabel)
	}
	if c.PropOpen {
		element = element.Attr("open", true)
	}
	if c.PropPending {
		element = element.Attr("pending", true)
	}
	if c.PropPendinglabel != "" {
		element = element.Attr("pendingLabel", c.PropPendinglabel)
	}
	if c.PropPlacement != "" {
		element = element.Attr("placement", string(c.PropPlacement))
	}
	if c.PropQuiet {
		element = element.Attr("quiet", true)
	}
	if c.PropReadonly {
		element = element.Attr("readonly", true)
	}
	if c.PropValue != "" {
		element = element.Attr("value", c.PropValue)
	}

	// Add event handlers
	if c.PropOnChange != nil {
		element = element.On("change", c.PropOnChange)
	}
	if c.PropOnSpOpened != nil {
		element = element.On("sp-opened", c.PropOnSpOpened)
	}

	// Add slots and children
	slotElements := []app.UI{}

	// Add content for default slot if specified
	if len(c.PropBody) > 0 {
		slotElements = append(slotElements, c.PropBody...)
	}

	// Add description slot
	if c.PropDescriptionSlot != nil {
		slotElem := c.PropDescriptionSlot
		if slotWithAttr, ok := slotElem.(interface{ Slot(string) app.UI }); ok {
			slotElem = slotWithAttr.Slot("description")
		} else {
			slotElem = app.Elem("div").
				Attr("slot", "description").
				Body(slotElem)
		}
		slotElements = append(slotElements, slotElem)
	}
	// Add label slot
	if c.PropLabelSlot != nil {
		slotElem := c.PropLabelSlot
		if slotWithAttr, ok := slotElem.(interface{ Slot(string) app.UI }); ok {
			slotElem = slotWithAttr.Slot("label")
		} else {
			slotElem = app.Elem("div").
				Attr("slot", "label").
				Body(slotElem)
		}
		slotElements = append(slotElements, slotElem)
	}
	// Add tooltip slot
	if c.PropTooltipSlot != nil {
		slotElem := c.PropTooltipSlot
		if slotWithAttr, ok := slotElem.(interface{ Slot(string) app.UI }); ok {
			slotElem = slotWithAttr.Slot("tooltip")
		} else {
			slotElem = app.Elem("div").
				Attr("slot", "tooltip").
				Body(slotElem)
		}
		slotElements = append(slotElements, slotElem)
	}

	// Add all elements to the component
	if len(slotElements) > 0 {
		element = element.Body(slotElements...)
	}

	// Apply styles, classes, and id
	element = element.Styles(c.styler.styles)

	// Apply classes if any
	if len(c.classer.classes) > 0 {
		element = element.Class(c.classer.classes...)
	}

	// Apply id if set
	if c.ider.id != "" {
		element = element.ID(c.ider.id)
	}

	return element
}
