// This file is generated by the generate_components.py script
// Do not edit this file manually

package sp

import "github.com/maxence-charriere/go-app/v10/pkg/app"

// TextfieldSize represents the The size of the textfield
type TextfieldSize string

// TextfieldSize values
const (
	TextfieldSizeS  TextfieldSize = "s"
	TextfieldSizeM  TextfieldSize = "m"
	TextfieldSizeL  TextfieldSize = "l"
	TextfieldSizeXl TextfieldSize = "xl"
)

// TextfieldType represents the The type of input that the textfield will accept
type TextfieldType string

// TextfieldType values
const (
	TextfieldTypeText     TextfieldType = "text"
	TextfieldTypePassword TextfieldType = "password"
	TextfieldTypeEmail    TextfieldType = "email"
	TextfieldTypeTel      TextfieldType = "tel"
	TextfieldTypeUrl      TextfieldType = "url"
)

// spectrumTextfield represents an sp-textfield component
type spectrumTextfield struct {
	app.Compo
	*styler[*spectrumTextfield]
	*classer[*spectrumTextfield]
	*ider[*spectrumTextfield]

	// Properties
	// What form of assistance should be provided when attempting to supply a value to the form control
	PropAutocomplete string
	// Disable this control. It will not receive focus or events
	PropDisabled bool
	// Whether a form control delivered with the multiline attribute will change size vertically to accommodate longer input
	PropGrows bool
	// Whether the value held by the form control is invalid
	PropInvalid bool
	// A string applied via aria-label to the form control when a user visible label is not provided
	PropLabel string
	// Defines the maximum string length that the user can enter
	PropMaxlength float64
	// Defines the minimum string length that the user can enter
	PropMinlength float64
	// Whether the form control should accept a value longer than one line
	PropMultiline bool
	// Name of the form control
	PropName string
	// Pattern the value must match to be valid
	PropPattern string
	// Text that appears in the form control when it has no value set
	PropPlaceholder string
	// Whether to display the form control with no visible background
	PropQuiet bool
	// Whether a user can interact with the value of the form control
	PropReadonly bool
	// Whether the form control will be found to be invalid when it holds no value
	PropRequired bool
	// The specific number of rows the form control should provide in the user interface
	PropRows float64
	// The size of the textfield
	PropSize TextfieldSize
	// The tab index to apply to this control. See general documentation about the tabindex HTML property
	PropTabindex float64
	// The type of input that the textfield will accept
	PropType TextfieldType
	// Whether the value held by the form control is valid
	PropValid bool
	// The value held by the form control
	PropValue string

	// Content slots
	PropHelpTextSlot         app.UI
	PropNegativeHelpTextSlot app.UI

	// Event handlers
	PropOnChange app.EventHandler
	PropOnInput  app.EventHandler
}

// ITextfield is the interface for sp-textfield component methods
type ITextfield interface {
	app.UI
	Styler[ITextfield]
	Classer[ITextfield]
	Ider[ITextfield]
	Autocomplete(string) ITextfield
	Disabled(bool) ITextfield
	SetDisabled() ITextfield
	Grows(bool) ITextfield
	SetGrows() ITextfield
	Invalid(bool) ITextfield
	SetInvalid() ITextfield
	Label(string) ITextfield
	Maxlength(float64) ITextfield
	Minlength(float64) ITextfield
	Multiline(bool) ITextfield
	SetMultiline() ITextfield
	Name(string) ITextfield
	Pattern(string) ITextfield
	Placeholder(string) ITextfield
	Quiet(bool) ITextfield
	SetQuiet() ITextfield
	Readonly(bool) ITextfield
	SetReadonly() ITextfield
	Required(bool) ITextfield
	SetRequired() ITextfield
	Rows(float64) ITextfield
	Size(TextfieldSize) ITextfield
	SizeS() ITextfield
	SizeM() ITextfield
	SizeL() ITextfield
	SizeXl() ITextfield
	Tabindex(float64) ITextfield
	Type(TextfieldType) ITextfield
	TypeText() ITextfield
	TypePassword() ITextfield
	TypeEmail() ITextfield
	TypeTel() ITextfield
	TypeUrl() ITextfield
	Valid(bool) ITextfield
	SetValid() ITextfield
	Value(string) ITextfield

	HelpText(app.UI) ITextfield
	NegativeHelpText(app.UI) ITextfield

	OnChange(app.EventHandler) ITextfield
	OnInput(app.EventHandler) ITextfield
}

// Textfield Textfield components are text boxes that allow users to input custom text entries with a keyboard. Various decorations can be displayed around the field to communicate the entry requirements.
func Textfield() ITextfield {
	element := &spectrumTextfield{
		PropDisabled:    false,
		PropGrows:       false,
		PropInvalid:     false,
		PropLabel:       "",
		PropMaxlength:   -1,
		PropMinlength:   -1,
		PropMultiline:   false,
		PropPlaceholder: "",
		PropQuiet:       false,
		PropReadonly:    false,
		PropRequired:    false,
		PropRows:        -1,
		PropSize:        TextfieldSizeM,
		PropTabindex:    0,
		PropType:        TextfieldTypeText,
		PropValid:       false,
		PropValue:       "",
	}

	element.styler = newStyler(element)
	element.classer = newClasser(element)
	element.ider = newIder(element)

	return element
}

// Autocomplete What form of assistance should be provided when attempting to supply a value to the form control
func (c *spectrumTextfield) Autocomplete(autocomplete string) ITextfield {
	c.PropAutocomplete = autocomplete
	return c
}

// Disabled Disable this control. It will not receive focus or events
func (c *spectrumTextfield) Disabled(disabled bool) ITextfield {
	c.PropDisabled = disabled
	return c
}

func (c *spectrumTextfield) SetDisabled() ITextfield {
	return c.Disabled(true)
}

// Grows Whether a form control delivered with the multiline attribute will change size vertically to accommodate longer input
func (c *spectrumTextfield) Grows(grows bool) ITextfield {
	c.PropGrows = grows
	return c
}

func (c *spectrumTextfield) SetGrows() ITextfield {
	return c.Grows(true)
}

// Invalid Whether the value held by the form control is invalid
func (c *spectrumTextfield) Invalid(invalid bool) ITextfield {
	c.PropInvalid = invalid
	return c
}

func (c *spectrumTextfield) SetInvalid() ITextfield {
	return c.Invalid(true)
}

// Label A string applied via aria-label to the form control when a user visible label is not provided
func (c *spectrumTextfield) Label(label string) ITextfield {
	c.PropLabel = label
	return c
}

// Maxlength Defines the maximum string length that the user can enter
func (c *spectrumTextfield) Maxlength(maxlength float64) ITextfield {
	c.PropMaxlength = maxlength
	return c
}

// Minlength Defines the minimum string length that the user can enter
func (c *spectrumTextfield) Minlength(minlength float64) ITextfield {
	c.PropMinlength = minlength
	return c
}

// Multiline Whether the form control should accept a value longer than one line
func (c *spectrumTextfield) Multiline(multiline bool) ITextfield {
	c.PropMultiline = multiline
	return c
}

func (c *spectrumTextfield) SetMultiline() ITextfield {
	return c.Multiline(true)
}

// Name Name of the form control
func (c *spectrumTextfield) Name(name string) ITextfield {
	c.PropName = name
	return c
}

// Pattern Pattern the value must match to be valid
func (c *spectrumTextfield) Pattern(pattern string) ITextfield {
	c.PropPattern = pattern
	return c
}

// Placeholder Text that appears in the form control when it has no value set
func (c *spectrumTextfield) Placeholder(placeholder string) ITextfield {
	c.PropPlaceholder = placeholder
	return c
}

// Quiet Whether to display the form control with no visible background
func (c *spectrumTextfield) Quiet(quiet bool) ITextfield {
	c.PropQuiet = quiet
	return c
}

func (c *spectrumTextfield) SetQuiet() ITextfield {
	return c.Quiet(true)
}

// Readonly Whether a user can interact with the value of the form control
func (c *spectrumTextfield) Readonly(readonly bool) ITextfield {
	c.PropReadonly = readonly
	return c
}

func (c *spectrumTextfield) SetReadonly() ITextfield {
	return c.Readonly(true)
}

// Required Whether the form control will be found to be invalid when it holds no value
func (c *spectrumTextfield) Required(required bool) ITextfield {
	c.PropRequired = required
	return c
}

func (c *spectrumTextfield) SetRequired() ITextfield {
	return c.Required(true)
}

// Rows The specific number of rows the form control should provide in the user interface
func (c *spectrumTextfield) Rows(rows float64) ITextfield {
	c.PropRows = rows
	return c
}

// Size The size of the textfield
func (c *spectrumTextfield) Size(size TextfieldSize) ITextfield {
	c.PropSize = size
	return c
}

func (c *spectrumTextfield) SizeS() ITextfield {
	return c.Size(TextfieldSizeS)
}
func (c *spectrumTextfield) SizeM() ITextfield {
	return c.Size(TextfieldSizeM)
}
func (c *spectrumTextfield) SizeL() ITextfield {
	return c.Size(TextfieldSizeL)
}
func (c *spectrumTextfield) SizeXl() ITextfield {
	return c.Size(TextfieldSizeXl)
}

// Tabindex The tab index to apply to this control. See general documentation about the tabindex HTML property
func (c *spectrumTextfield) Tabindex(tabindex float64) ITextfield {
	c.PropTabindex = tabindex
	return c
}

// Type The type of input that the textfield will accept
func (c *spectrumTextfield) Type(typeValue TextfieldType) ITextfield {
	c.PropType = typeValue
	return c
}

func (c *spectrumTextfield) TypeText() ITextfield {
	return c.Type(TextfieldTypeText)
}
func (c *spectrumTextfield) TypePassword() ITextfield {
	return c.Type(TextfieldTypePassword)
}
func (c *spectrumTextfield) TypeEmail() ITextfield {
	return c.Type(TextfieldTypeEmail)
}
func (c *spectrumTextfield) TypeTel() ITextfield {
	return c.Type(TextfieldTypeTel)
}
func (c *spectrumTextfield) TypeUrl() ITextfield {
	return c.Type(TextfieldTypeUrl)
}

// Valid Whether the value held by the form control is valid
func (c *spectrumTextfield) Valid(valid bool) ITextfield {
	c.PropValid = valid
	return c
}

func (c *spectrumTextfield) SetValid() ITextfield {
	return c.Valid(true)
}

// Value The value held by the form control
func (c *spectrumTextfield) Value(value string) ITextfield {
	c.PropValue = value
	return c
}

// Default or non-negative help text to associate to your form element
func (c *spectrumTextfield) HelpText(content app.UI) ITextfield {
	c.PropHelpTextSlot = content

	return c
}

// Negative help text to associate to your form element when invalid
func (c *spectrumTextfield) NegativeHelpText(content app.UI) ITextfield {
	c.PropNegativeHelpTextSlot = content

	return c
}

// An alteration to the value of the element has been committed by the user
func (c *spectrumTextfield) OnChange(handler app.EventHandler) ITextfield {
	c.PropOnChange = handler

	return c
}

// The value of the element has changed
func (c *spectrumTextfield) OnInput(handler app.EventHandler) ITextfield {
	c.PropOnInput = handler

	return c
}

// Style sets a style property with a value
func (c *spectrumTextfield) Style(key, format string, values ...any) ITextfield {
	return c.styler.Style(key, format, values...)
}

// Styles sets multiple style properties
func (c *spectrumTextfield) Styles(styles map[string]string) ITextfield {
	return c.styler.Styles(styles)
}

// Class adds a class to the element
func (c *spectrumTextfield) Class(class string) ITextfield {
	return c.classer.Class(class)
}

// Classes adds multiple classes to the element
func (c *spectrumTextfield) Classes(classes ...string) ITextfield {
	return c.classer.Classes(classes...)
}

// Id sets the id of the element
func (c *spectrumTextfield) Id(id string) ITextfield {
	return c.ider.Id(id)
}

// Render renders the sp-textfield component
func (c *spectrumTextfield) Render() app.UI {
	element := app.Elem("sp-textfield")

	// Set attributes
	if c.PropAutocomplete != "" {
		element = element.Attr("autocomplete", c.PropAutocomplete)
	}
	if c.PropDisabled {
		element = element.Attr("disabled", true)
	}
	if c.PropGrows {
		element = element.Attr("grows", true)
	}
	if c.PropInvalid {
		element = element.Attr("invalid", true)
	}
	if c.PropLabel != "" {
		element = element.Attr("label", c.PropLabel)
	}
	if c.PropMaxlength != 0 {
		element = element.Attr("maxlength", c.PropMaxlength)
	}
	if c.PropMinlength != 0 {
		element = element.Attr("minlength", c.PropMinlength)
	}
	if c.PropMultiline {
		element = element.Attr("multiline", true)
	}
	if c.PropName != "" {
		element = element.Attr("name", c.PropName)
	}
	if c.PropPattern != "" {
		element = element.Attr("pattern", c.PropPattern)
	}
	if c.PropPlaceholder != "" {
		element = element.Attr("placeholder", c.PropPlaceholder)
	}
	if c.PropQuiet {
		element = element.Attr("quiet", true)
	}
	if c.PropReadonly {
		element = element.Attr("readonly", true)
	}
	if c.PropRequired {
		element = element.Attr("required", true)
	}
	if c.PropRows != 0 {
		element = element.Attr("rows", c.PropRows)
	}
	if c.PropSize != "" {
		element = element.Attr("size", string(c.PropSize))
	}
	if c.PropTabindex != 0 {
		element = element.Attr("tabindex", c.PropTabindex)
	}
	if c.PropType != "" {
		element = element.Attr("type", string(c.PropType))
	}
	if c.PropValid {
		element = element.Attr("valid", true)
	}
	if c.PropValue != "" {
		element = element.Attr("value", c.PropValue)
	}

	// Add event handlers
	if c.PropOnChange != nil {
		element = element.On("change", c.PropOnChange)
	}
	if c.PropOnInput != nil {
		element = element.On("input", c.PropOnInput)
	}

	// Add slots and children
	slotElements := []app.UI{}

	// Add help-text slot
	if c.PropHelpTextSlot != nil {
		slotElem := c.PropHelpTextSlot
		if slotWithAttr, ok := slotElem.(interface{ Slot(string) app.UI }); ok {
			slotElem = slotWithAttr.Slot("help-text")
		} else {
			slotElem = app.Elem("div").
				Attr("slot", "help-text").
				Body(slotElem)
		}
		slotElements = append(slotElements, slotElem)
	}
	// Add negative-help-text slot
	if c.PropNegativeHelpTextSlot != nil {
		slotElem := c.PropNegativeHelpTextSlot
		if slotWithAttr, ok := slotElem.(interface{ Slot(string) app.UI }); ok {
			slotElem = slotWithAttr.Slot("negative-help-text")
		} else {
			slotElem = app.Elem("div").
				Attr("slot", "negative-help-text").
				Body(slotElem)
		}
		slotElements = append(slotElements, slotElem)
	}

	// Add all elements to the component
	if len(slotElements) > 0 {
		element = element.Body(slotElements...)
	}

	// Apply styles, classes, and id
	element = element.Styles(c.styler.styles)

	// Apply classes if any
	if len(c.classer.classes) > 0 {
		element = element.Class(c.classer.classes...)
	}

	// Apply id if set
	if c.ider.id != "" {
		element = element.ID(c.ider.id)
	}

	return element
}
