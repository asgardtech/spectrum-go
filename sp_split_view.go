// This file is generated by the generate_components.py script
// Do not edit this file manually

package sp

import "github.com/maxence-charriere/go-app/v10/pkg/app"

// spectrumSplitView represents an sp-split-view component
type spectrumSplitView struct {
	app.Compo
	*styler[*spectrumSplitView]
	*classer[*spectrumSplitView]
	*ider[*spectrumSplitView]

	// Properties
	// Whether panels can be collapsed completely
	PropCollapsible bool
	// Accessible label for the resizable divider
	PropLabel string
	// The maximum size of the primary pane (in pixels)
	PropPrimaryMax float64
	// The minimum size of the primary pane (in pixels)
	PropPrimaryMin float64
	// The initial size of the primary pane (in pixels or percentage)
	PropPrimarySize string
	// Whether the split view can be resized by the user
	PropResizable bool
	// The maximum size of the secondary pane (in pixels)
	PropSecondaryMax float64
	// The minimum size of the secondary pane (in pixels)
	PropSecondaryMin float64
	// The current splitter position (in pixels)
	PropSplitterPos float64
	// Whether the split view is arranged vertically
	PropVertical bool

	// Content for default slot
	PropBody []app.UI

	// Content slots

	// Event handlers
	PropOnChange app.EventHandler
}

// ISplitView is the interface for sp-split-view component methods
type ISplitView interface {
	app.UI
	Styler[ISplitView]
	Classer[ISplitView]
	Ider[ISplitView]
	Collapsible(bool) ISplitView
	SetCollapsible() ISplitView
	Label(string) ISplitView
	PrimaryMax(float64) ISplitView
	PrimaryMin(float64) ISplitView
	PrimarySize(string) ISplitView
	Resizable(bool) ISplitView
	SetResizable() ISplitView
	SecondaryMax(float64) ISplitView
	SecondaryMin(float64) ISplitView
	SplitterPos(float64) ISplitView
	Vertical(bool) ISplitView
	SetVertical() ISplitView

	Body(...app.UI) ISplitView
	AddToBody(app.UI) ISplitView
	Text(string) ISplitView

	OnChange(app.EventHandler) ISplitView
}

// SplitView An sp-split-view element delivers its first two direct child elements in a horizontal or vertical orientation that distributes the available page real estate. When resizable, it provides a pointer and keyboard accessible affordance for users to customize distribution.
func SplitView() ISplitView {
	element := &spectrumSplitView{
		PropCollapsible:  false,
		PropLabel:        "Resize the panels",
		PropPrimaryMax:   0,
		PropPrimaryMin:   0,
		PropResizable:    false,
		PropSecondaryMax: 0,
		PropSecondaryMin: 0,
		PropSplitterPos:  0,
		PropVertical:     false,
		PropBody:         []app.UI{},
	}

	element.styler = newStyler(element)
	element.classer = newClasser(element)
	element.ider = newIder(element)

	return element
}

// Collapsible Whether panels can be collapsed completely
func (c *spectrumSplitView) Collapsible(collapsible bool) ISplitView {
	c.PropCollapsible = collapsible
	return c
}

func (c *spectrumSplitView) SetCollapsible() ISplitView {
	return c.Collapsible(true)
}

// Label Accessible label for the resizable divider
func (c *spectrumSplitView) Label(label string) ISplitView {
	c.PropLabel = label
	return c
}

// PrimaryMax The maximum size of the primary pane (in pixels)
func (c *spectrumSplitView) PrimaryMax(primaryMax float64) ISplitView {
	c.PropPrimaryMax = primaryMax
	return c
}

// PrimaryMin The minimum size of the primary pane (in pixels)
func (c *spectrumSplitView) PrimaryMin(primaryMin float64) ISplitView {
	c.PropPrimaryMin = primaryMin
	return c
}

// PrimarySize The initial size of the primary pane (in pixels or percentage)
func (c *spectrumSplitView) PrimarySize(primarySize string) ISplitView {
	c.PropPrimarySize = primarySize
	return c
}

// Resizable Whether the split view can be resized by the user
func (c *spectrumSplitView) Resizable(resizable bool) ISplitView {
	c.PropResizable = resizable
	return c
}

func (c *spectrumSplitView) SetResizable() ISplitView {
	return c.Resizable(true)
}

// SecondaryMax The maximum size of the secondary pane (in pixels)
func (c *spectrumSplitView) SecondaryMax(secondaryMax float64) ISplitView {
	c.PropSecondaryMax = secondaryMax
	return c
}

// SecondaryMin The minimum size of the secondary pane (in pixels)
func (c *spectrumSplitView) SecondaryMin(secondaryMin float64) ISplitView {
	c.PropSecondaryMin = secondaryMin
	return c
}

// SplitterPos The current splitter position (in pixels)
func (c *spectrumSplitView) SplitterPos(splitterPos float64) ISplitView {
	c.PropSplitterPos = splitterPos
	return c
}

// Vertical Whether the split view is arranged vertically
func (c *spectrumSplitView) Vertical(vertical bool) ISplitView {
	c.PropVertical = vertical
	return c
}

func (c *spectrumSplitView) SetVertical() ISplitView {
	return c.Vertical(true)
}

// Body sets the content for the default slot
func (c *spectrumSplitView) Body(elements ...app.UI) ISplitView {
	c.PropBody = elements
	return c
}

// AddToBody adds a UI element to the default slot
func (c *spectrumSplitView) AddToBody(element app.UI) ISplitView {
	c.PropBody = append(c.PropBody, element)
	return c
}

// Text sets text content for the default slot
func (c *spectrumSplitView) Text(text string) ISplitView {
	c.PropBody = []app.UI{app.Text(text)}
	return c
}

// Announces the new position of the splitter
func (c *spectrumSplitView) OnChange(handler app.EventHandler) ISplitView {
	c.PropOnChange = handler

	return c
}

// Style sets a style property with a value
func (c *spectrumSplitView) Style(key, format string, values ...any) ISplitView {
	return c.styler.Style(key, format, values...)
}

// Styles sets multiple style properties
func (c *spectrumSplitView) Styles(styles map[string]string) ISplitView {
	return c.styler.Styles(styles)
}

// Class adds a class to the element
func (c *spectrumSplitView) Class(class string) ISplitView {
	return c.classer.Class(class)
}

// Classes adds multiple classes to the element
func (c *spectrumSplitView) Classes(classes ...string) ISplitView {
	return c.classer.Classes(classes...)
}

// Id sets the id of the element
func (c *spectrumSplitView) Id(id string) ISplitView {
	return c.ider.Id(id)
}

// Render renders the sp-split-view component
func (c *spectrumSplitView) Render() app.UI {
	element := app.Elem("sp-split-view")

	// Set attributes
	if c.PropCollapsible {
		element = element.Attr("collapsible", true)
	}
	if c.PropLabel != "" {
		element = element.Attr("label", c.PropLabel)
	}
	if c.PropPrimaryMax != 0 {
		element = element.Attr("primary-max", c.PropPrimaryMax)
	}
	if c.PropPrimaryMin != 0 {
		element = element.Attr("primary-min", c.PropPrimaryMin)
	}
	if c.PropPrimarySize != "" {
		element = element.Attr("primary-size", c.PropPrimarySize)
	}
	if c.PropResizable {
		element = element.Attr("resizable", true)
	}
	if c.PropSecondaryMax != 0 {
		element = element.Attr("secondary-max", c.PropSecondaryMax)
	}
	if c.PropSecondaryMin != 0 {
		element = element.Attr("secondary-min", c.PropSecondaryMin)
	}
	if c.PropSplitterPos != 0 {
		element = element.Attr("splitter-pos", c.PropSplitterPos)
	}
	if c.PropVertical {
		element = element.Attr("vertical", true)
	}

	// Add event handlers
	if c.PropOnChange != nil {
		element = element.On("change", c.PropOnChange)
	}

	// Add slots and children
	slotElements := []app.UI{}

	// Add content for default slot if specified
	if len(c.PropBody) > 0 {
		slotElements = append(slotElements, c.PropBody...)
	}

	// Add all elements to the component
	if len(slotElements) > 0 {
		element = element.Body(slotElements...)
	}

	// Apply styles, classes, and id
	element = element.Styles(c.styler.styles)

	// Apply classes if any
	if len(c.classer.classes) > 0 {
		element = element.Class(c.classer.classes...)
	}

	// Apply id if set
	if c.ider.id != "" {
		element = element.ID(c.ider.id)
	}

	return element
}
